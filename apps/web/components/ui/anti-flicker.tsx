'use client'\n\nimport React, { useState, useEffect, useRef, useMemo, ReactNode } from 'react'\nimport { cn } from '@/lib/utils'\n\n// ============================================================================\n// COMPONENTE ANTI-PARPADEO UNIVERSAL - STREAMING DE DATOS SIN FLICKER\n// ============================================================================\n\ninterface AntiFlickerWrapperProps {\n  children: ReactNode\n  className?: string\n  isLoading?: boolean\n  isEmpty?: boolean\n  error?: string | null\n  enableTransitions?: boolean\n  transitionDuration?: number\n  loadingComponent?: ReactNode\n  emptyComponent?: ReactNode\n  errorComponent?: ReactNode\n}\n\nexport function AntiFlickerWrapper({\n  children,\n  className,\n  isLoading = false,\n  isEmpty = false,\n  error = null,\n  enableTransitions = true,\n  transitionDuration = 300,\n  loadingComponent,\n  emptyComponent,\n  errorComponent\n}: AntiFlickerWrapperProps) {\n  const [displayContent, setDisplayContent] = useState<ReactNode>(children)\n  const [isTransitioning, setIsTransitioning] = useState(false)\n  const prevChildrenRef = useRef<ReactNode>(children)\n  const contentRef = useRef<HTMLDivElement>(null)\n\n  // Detectar cambios en el contenido\n  useEffect(() => {\n    // Solo actualizar si hay contenido válido nuevo\n    if (!isLoading && !error && !isEmpty && children !== prevChildrenRef.current) {\n      if (enableTransitions) {\n        setIsTransitioning(true)\n        \n        // Aplicar nueva data después de una breve transición\n        setTimeout(() => {\n          setDisplayContent(children)\n          prevChildrenRef.current = children\n          setIsTransitioning(false)\n        }, 50) // Micro-delay para suavidad\n      } else {\n        setDisplayContent(children)\n        prevChildrenRef.current = children\n      }\n    }\n  }, [children, isLoading, error, isEmpty, enableTransitions])\n\n  // Estados de visualización\n  const showLoading = isLoading && !displayContent\n  const showError = error && !displayContent\n  const showEmpty = isEmpty && !displayContent && !isLoading && !error\n  const showContent = !showLoading && !showError && !showEmpty\n\n  // Componente de carga por defecto\n  const defaultLoadingComponent = (\n    <div className=\"flex items-center justify-center py-12\">\n      <div className=\"flex flex-col items-center space-y-3\">\n        <div className=\"animate-spin rounded-full h-8 w-8 border-b-2 border-blue-600\"></div>\n        <p className=\"text-sm text-gray-600\">Cargando datos...</p>\n      </div>\n    </div>\n  )\n\n  // Componente vacío por defecto\n  const defaultEmptyComponent = (\n    <div className=\"flex items-center justify-center py-12\">\n      <div className=\"text-center\">\n        <div className=\"w-16 h-16 mx-auto mb-4 text-gray-400\">\n          <svg viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" strokeWidth=\"2\">\n            <circle cx=\"12\" cy=\"12\" r=\"10\"/>\n            <path d=\"M12 6v6l4 2\"/>\n          </svg>\n        </div>\n        <p className=\"text-sm text-gray-600\">No hay datos disponibles</p>\n      </div>\n    </div>\n  )\n\n  // Componente de error por defecto\n  const defaultErrorComponent = (\n    <div className=\"flex items-center justify-center py-12\">\n      <div className=\"text-center\">\n        <div className=\"w-16 h-16 mx-auto mb-4 text-red-400\">\n          <svg viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" strokeWidth=\"2\">\n            <circle cx=\"12\" cy=\"12\" r=\"10\"/>\n            <line x1=\"15\" y1=\"9\" x2=\"9\" y2=\"15\"/>\n            <line x1=\"9\" y1=\"9\" x2=\"15\" y2=\"15\"/>\n          </svg>\n        </div>\n        <p className=\"text-sm text-red-600\">{error || 'Error al cargar datos'}</p>\n      </div>\n    </div>\n  )\n\n  return (\n    <div \n      ref={contentRef}\n      className={cn(\n        \"relative overflow-hidden\",\n        enableTransitions && \"transition-all duration-300 ease-in-out\",\n        isTransitioning && \"opacity-95\",\n        className\n      )}\n    >\n      {showLoading && (loadingComponent || defaultLoadingComponent)}\n      {showError && (errorComponent || defaultErrorComponent)}\n      {showEmpty && (emptyComponent || defaultEmptyComponent)}\n      {showContent && displayContent}\n    </div>\n  )\n}\n\n// ============================================================================\n// TABLA ANTI-PARPADEO CON ACTUALIZACIONES CELULARES\n// ============================================================================\n\ninterface AntiFlickerTableProps {\n  data: any[]\n  columns: {\n    key: string\n    label: string\n    render?: (item: any, value: any) => ReactNode\n    className?: string\n    sortable?: boolean\n  }[]\n  className?: string\n  isLoading?: boolean\n  error?: string | null\n  keyExtractor?: (item: any, index: number) => string\n  onRowClick?: (item: any) => void\n  enableHighlight?: boolean\n  highlightDuration?: number\n}\n\nexport function AntiFlickerTable({\n  data,\n  columns,\n  className,\n  isLoading = false,\n  error = null,\n  keyExtractor = (item, index) => item.id || index.toString(),\n  onRowClick,\n  enableHighlight = true,\n  highlightDuration = 1000\n}: AntiFlickerTableProps) {\n  const [displayData, setDisplayData] = useState(data)\n  const [highlightedCells, setHighlightedCells] = useState(new Set<string>())\n  const prevDataRef = useRef(data)\n  const highlightTimeoutRef = useRef<{ [key: string]: NodeJS.Timeout }>({})\n\n  // Detectar cambios a nivel celular\n  useEffect(() => {\n    if (!isLoading && !error && data.length > 0) {\n      const newHighlights = new Set<string>()\n      \n      // Comparar cada celda para detectar cambios\n      data.forEach((newItem, rowIndex) => {\n        const key = keyExtractor(newItem, rowIndex)\n        const oldItem = prevDataRef.current.find(item => keyExtractor(item, 0) === key)\n        \n        if (oldItem) {\n          columns.forEach(column => {\n            const oldValue = oldItem[column.key]\n            const newValue = newItem[column.key]\n            \n            if (JSON.stringify(oldValue) !== JSON.stringify(newValue)) {\n              const cellKey = `${key}-${column.key}`\n              newHighlights.add(cellKey)\n              \n              // Programar eliminación del highlight\n              if (highlightTimeoutRef.current[cellKey]) {\n                clearTimeout(highlightTimeoutRef.current[cellKey])\n              }\n              \n              highlightTimeoutRef.current[cellKey] = setTimeout(() => {\n                setHighlightedCells(prev => {\n                  const updated = new Set(prev)\n                  updated.delete(cellKey)\n                  return updated\n                })\n                delete highlightTimeoutRef.current[cellKey]\n              }, highlightDuration)\n            }\n          })\n        }\n      })\n      \n      setHighlightedCells(prev => new Set([...prev, ...newHighlights]))\n      setDisplayData(data)\n      prevDataRef.current = data\n    }\n  }, [data, isLoading, error, columns, keyExtractor, highlightDuration])\n\n  // Cleanup timeouts\n  useEffect(() => {\n    return () => {\n      Object.values(highlightTimeoutRef.current).forEach(clearTimeout)\n    }\n  }, [])\n\n  const tableContent = (\n    <div className=\"overflow-x-auto\">\n      <table className=\"w-full\">\n        <thead>\n          <tr className=\"border-b border-gray-200\">\n            {columns.map(column => (\n              <th \n                key={column.key}\n                className={cn(\n                  \"px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider\",\n                  column.className\n                )}\n              >\n                {column.label}\n              </th>\n            ))}\n          </tr>\n        </thead>\n        <tbody>\n          {displayData.map((item, rowIndex) => {\n            const rowKey = keyExtractor(item, rowIndex)\n            return (\n              <tr \n                key={rowKey}\n                className={cn(\n                  \"hover:bg-gray-50 transition-colors duration-150\",\n                  onRowClick && \"cursor-pointer\"\n                )}\n                onClick={() => onRowClick?.(item)}\n              >\n                {columns.map(column => {\n                  const cellKey = `${rowKey}-${column.key}`\n                  const isHighlighted = enableHighlight && highlightedCells.has(cellKey)\n                  const value = item[column.key]\n                  \n                  return (\n                    <td \n                      key={column.key}\n                      className={cn(\n                        \"px-6 py-4 whitespace-nowrap text-sm transition-all duration-300\",\n                        isHighlighted && \"bg-blue-100 border-l-4 border-blue-500 animate-pulse\",\n                        column.className\n                      )}\n                    >\n                      {column.render ? column.render(item, value) : value}\n                    </td>\n                  )\n                })}\n              </tr>\n            )\n          })}\n        </tbody>\n      </table>\n    </div>\n  )\n\n  return (\n    <AntiFlickerWrapper\n      isLoading={isLoading}\n      isEmpty={displayData.length === 0}\n      error={error}\n      className={className}\n    >\n      {tableContent}\n    </AntiFlickerWrapper>\n  )\n}\n\n// ============================================================================\n// CARDS ANTI-PARPADEO PARA MÉTRICAS\n// ============================================================================\n\ninterface AntiFlickerMetricCardProps {\n  title: string\n  value: string | number\n  subtitle?: string\n  trend?: 'up' | 'down' | 'neutral'\n  trendValue?: string\n  icon?: ReactNode\n  className?: string\n  isLoading?: boolean\n  valueFormatter?: (value: any) => string\n}\n\nexport function AntiFlickerMetricCard({\n  title,\n  value,\n  subtitle,\n  trend,\n  trendValue,\n  icon,\n  className,\n  isLoading = false,\n  valueFormatter\n}: AntiFlickerMetricCardProps) {\n  const [displayValue, setDisplayValue] = useState(value)\n  const [isUpdating, setIsUpdating] = useState(false)\n  const prevValueRef = useRef(value)\n\n  useEffect(() => {\n    if (!isLoading && value !== prevValueRef.current) {\n      setIsUpdating(true)\n      \n      // Brief highlight effect for value changes\n      setTimeout(() => {\n        setDisplayValue(value)\n        prevValueRef.current = value\n        setIsUpdating(false)\n      }, 150)\n    }\n  }, [value, isLoading])\n\n  const formattedValue = valueFormatter ? valueFormatter(displayValue) : displayValue\n\n  const trendIcon = trend === 'up' ? '↗️' : trend === 'down' ? '↘️' : '➡️'\n  const trendColor = trend === 'up' ? 'text-green-600' : trend === 'down' ? 'text-red-600' : 'text-gray-600'\n\n  return (\n    <AntiFlickerWrapper\n      isLoading={isLoading && !displayValue}\n      className={cn(\n        \"bg-white rounded-lg shadow-sm border border-gray-200 p-6\",\n        className\n      )}\n    >\n      <div className=\"flex items-center justify-between\">\n        <div className=\"flex-1\">\n          <p className=\"text-sm font-medium text-gray-600\">{title}</p>\n          <div className={cn(\n            \"mt-2 flex items-baseline transition-all duration-300\",\n            isUpdating && \"bg-blue-100 rounded px-2 py-1 border-l-4 border-blue-500\"\n          )}>\n            <p className=\"text-2xl font-semibold text-gray-900\">\n              {formattedValue}\n            </p>\n            {trend && trendValue && (\n              <p className={cn(\"ml-2 flex items-baseline text-sm font-medium\", trendColor)}>\n                <span className=\"mr-1\">{trendIcon}</span>\n                {trendValue}\n              </p>\n            )}\n          </div>\n          {subtitle && (\n            <p className=\"mt-1 text-sm text-gray-500\">{subtitle}</p>\n          )}\n        </div>\n        {icon && (\n          <div className=\"flex-shrink-0\">\n            <div className=\"w-8 h-8 text-gray-400\">\n              {icon}\n            </div>\n          </div>\n        )}\n      </div>\n    </AntiFlickerWrapper>\n  )\n}\n\n// ============================================================================\n// HOOK PARA CONTEO ANIMADO SIN PARPADEOS\n// ============================================================================\n\nexport function useAntiFlickerCounter(\n  targetValue: number,\n  duration: number = 1000,\n  enabled: boolean = true\n) {\n  const [displayValue, setDisplayValue] = useState(targetValue)\n  const [isAnimating, setIsAnimating] = useState(false)\n  const animationRef = useRef<number>()\n\n  useEffect(() => {\n    if (!enabled || targetValue === displayValue) return\n\n    setIsAnimating(true)\n    const startValue = displayValue\n    const difference = targetValue - startValue\n    const startTime = performance.now()\n\n    const animate = (currentTime: number) => {\n      const elapsed = currentTime - startTime\n      const progress = Math.min(elapsed / duration, 1)\n      \n      // Easing function for smooth animation\n      const easeOutCubic = (t: number) => 1 - Math.pow(1 - t, 3)\n      const easedProgress = easeOutCubic(progress)\n      \n      const currentValue = startValue + (difference * easedProgress)\n      setDisplayValue(currentValue)\n\n      if (progress < 1) {\n        animationRef.current = requestAnimationFrame(animate)\n      } else {\n        setDisplayValue(targetValue)\n        setIsAnimating(false)\n      }\n    }\n\n    animationRef.current = requestAnimationFrame(animate)\n\n    return () => {\n      if (animationRef.current) {\n        cancelAnimationFrame(animationRef.current)\n      }\n    }\n  }, [targetValue, displayValue, duration, enabled])\n\n  return { value: displayValue, isAnimating }\n}\n\n// ============================================================================\n// UTILIDADES PARA FORMATEO DE STREAMING DATA\n// ============================================================================\n\nexport const formatters = {\n  currency: (value: number) => new Intl.NumberFormat('en-US', {\n    style: 'currency',\n    currency: 'USD',\n    minimumFractionDigits: 2,\n    maximumFractionDigits: 2\n  }).format(value),\n  \n  percentage: (value: number) => `${value.toFixed(2)}%`,\n  \n  number: (value: number) => new Intl.NumberFormat('en-US').format(value),\n  \n  compact: (value: number) => {\n    if (value >= 1000000) {\n      return `${(value / 1000000).toFixed(1)}M`\n    } else if (value >= 1000) {\n      return `${(value / 1000).toFixed(1)}K`\n    }\n    return value.toString()\n  },\n  \n  timestamp: (value: string | Date) => {\n    const date = new Date(value)\n    return date.toLocaleTimeString('es-ES', { \n      hour: '2-digit', \n      minute: '2-digit',\n      second: '2-digit'\n    })\n  }\n}\n"