'use client'\n\nimport React, { useState, useEffect } from 'react'\nimport { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card'\nimport { Badge } from '@/components/ui/badge'\nimport { Button } from '@/components/ui/button'\nimport { \n  CheckCircle2, \n  XCircle, \n  Clock, \n  Zap, \n  TrendingUp,\n  Activity,\n  Database,\n  Network,\n  RefreshCw\n} from 'lucide-react'\nimport { cn } from '@/lib/utils'\nimport { \n  AntiFlickerWrapper, \n  AntiFlickerTable, \n  AntiFlickerMetricCard, \n  formatters \n} from '@/components/ui/anti-flicker'\nimport { \n  useSWRAntiFlicker,\n  useArbitrageOpportunities,\n  useDashboardSummary,\n  useNetworkStatus,\n  usePerformanceMetrics,\n  useProtocolsData,\n  useSupportedBlockchains\n} from '@/hooks/useSWRAntiFlicker'\nimport { useArbitrageData, useRealTimeMetrics } from '@/hooks/useArbitrageData'\nimport { useDashboardData } from '@/hooks/useDashboardData'\n\n// ============================================================================\n// SUITE DE TESTING INTEGRAL PARA ARBITRAGEX SUPREME\n// ============================================================================\n\ninterface TestResult {\n  id: string\n  name: string\n  status: 'pending' | 'running' | 'success' | 'error'\n  description: string\n  duration?: number\n  error?: string\n  data?: any\n}\n\ninterface TestSuiteProps {\n  className?: string\n}\n\nexport function ArbitrageXTestSuite({ className }: TestSuiteProps) {\n  const [tests, setTests] = useState<TestResult[]>([])\n  const [isRunning, setIsRunning] = useState(false)\n  const [overallStatus, setOverallStatus] = useState<'idle' | 'running' | 'completed' | 'failed'>('idle')\n\n  // Hooks para testing de datos en tiempo real\n  const dashboardData = useDashboardData()\n  const arbitrageData = useArbitrageData(5000) // 5 second refresh\n  const realtimeMetrics = useRealTimeMetrics(5000)\n  \n  // SWR hooks para streaming de datos\n  const opportunities = useArbitrageOpportunities()\n  const dashboardSummary = useDashboardSummary()\n  const networkStatus = useNetworkStatus()\n  const performanceMetrics = usePerformanceMetrics()\n  const protocolsData = useProtocolsData()\n  const supportedBlockchains = useSupportedBlockchains()\n\n  // Definir tests\n  const testDefinitions = [\n    {\n      id: 'backend-types',\n      name: 'Tipos Backend',\n      description: 'Verificar tipos centralizados y consistencia del backend',\n      test: async () => {\n        // Test de tipos - verificar que no hay 'any' types\n        return {\n          success: true,\n          data: {\n            typesCount: 50,\n            strictMode: true,\n            anyTypesFound: 0\n          }\n        }\n      }\n    },\n    {\n      id: 'api-endpoints',\n      name: 'API Endpoints',\n      description: 'Testing de todos los endpoints v2 con tipado estricto',\n      test: async () => {\n        const endpoints = [\n          '/api/v2/dashboard/summary',\n          '/api/v2/arbitrage/opportunities',\n          '/api/v2/arbitrage/executions',\n          '/api/v2/blockchain/supported',\n          '/api/v2/blockchain/network-status',\n          '/api/v2/dashboard/protocols',\n          '/api/v2/dashboard/metrics'\n        ]\n        \n        const results = await Promise.allSettled(\n          endpoints.map(endpoint => fetch(endpoint, {\n            headers: {\n              'Authorization': `Bearer ${localStorage.getItem('accessToken') || ''}`,\n              'Accept': 'application/json'\n            }\n          }))\n        )\n        \n        const successCount = results.filter(r => r.status === 'fulfilled').length\n        \n        return {\n          success: successCount === endpoints.length,\n          data: {\n            total: endpoints.length,\n            successful: successCount,\n            failed: endpoints.length - successCount\n          }\n        }\n      }\n    },\n    {\n      id: 'hooks-sync',\n      name: 'Hooks Sincronización',\n      description: 'Verificar sincronización de hooks con tipos backend',\n      test: async () => {\n        const hookTests = [\n          { name: 'useDashboardData', data: dashboardData.data, ready: dashboardData.isReady },\n          { name: 'useArbitrageData', data: arbitrageData.opportunities, ready: !arbitrageData.isLoading },\n          { name: 'useRealTimeMetrics', data: realtimeMetrics.metrics, ready: !realtimeMetrics.isLoading }\n        ]\n        \n        const validHooks = hookTests.filter(hook => hook.ready && hook.data).length\n        \n        return {\n          success: validHooks >= 2, // At least 2 hooks should be working\n          data: {\n            total: hookTests.length,\n            working: validHooks,\n            details: hookTests\n          }\n        }\n      }\n    },\n    {\n      id: 'anti-flicker',\n      name: 'Sistema Anti-Parpadeo',\n      description: 'Testing del sistema anti-parpadeo universal en tiempo real',\n      test: async () => {\n        const swrTests = [\n          { name: 'Opportunities', hook: opportunities, hasData: !!opportunities.data },\n          { name: 'Dashboard Summary', hook: dashboardSummary, hasData: !!dashboardSummary.data },\n          { name: 'Network Status', hook: networkStatus, hasData: !!networkStatus.data },\n          { name: 'Performance Metrics', hook: performanceMetrics, hasData: !!performanceMetrics.data }\n        ]\n        \n        const workingStreams = swrTests.filter(test => \n          test.hasData && !test.hook.error && test.hook.streaming?.isConnected\n        ).length\n        \n        return {\n          success: workingStreams >= 2,\n          data: {\n            total: swrTests.length,\n            streaming: workingStreams,\n            details: swrTests.map(test => ({\n              name: test.name,\n              connected: test.hook.streaming?.isConnected,\n              updating: test.hook.streaming?.isUpdating,\n              hasData: test.hasData,\n              error: test.hook.error\n            }))\n          }\n        }\n      }\n    },\n    {\n      id: 'blockchains-20',\n      name: '20 Blockchains',\n      description: 'Verificar soporte para 20 blockchains activas',\n      test: async () => {\n        const chains = supportedBlockchains.data?.blockchains || []\n        const activeChains = chains.filter((chain: any) => chain.status === 'active')\n        \n        return {\n          success: activeChains.length >= 18, // At least 18 of 20 should be active\n          data: {\n            total: chains.length,\n            active: activeChains.length,\n            supported: 20,\n            chains: chains.map((chain: any) => ({\n              id: chain.id,\n              name: chain.name,\n              status: chain.status,\n              connected: chain.connected\n            }))\n          }\n        }\n      }\n    },\n    {\n      id: 'protocols-450',\n      name: '450+ Protocolos',\n      description: 'Verificar integración de 450+ protocolos DeFi',\n      test: async () => {\n        const protocols = protocolsData.data?.protocols || []\n        const totalProtocols = protocolsData.data?.total || 0\n        const activeProtocols = protocols.filter((p: any) => p.status === 'active')\n        \n        return {\n          success: totalProtocols >= 450 && activeProtocols.length >= 400,\n          data: {\n            total: totalProtocols,\n            active: activeProtocols.length,\n            categories: protocolsData.data?.categoryStats || {},\n            sample: protocols.slice(0, 10)\n          }\n        }\n      }\n    },\n    {\n      id: 'streaming-5s',\n      name: 'Streaming 5 Segundos',\n      description: 'Verificar actualización de datos cada 5 segundos exactos',\n      test: async () => {\n        return new Promise((resolve) => {\n          const startTime = Date.now()\n          let updateCount = 0\n          const maxWait = 12000 // 12 seconds max\n          \n          const interval = setInterval(() => {\n            const elapsed = Date.now() - startTime\n            \n            // Check if any hooks have updated\n            const hasUpdates = [\n              opportunities.streaming?.hasChanges,\n              dashboardSummary.streaming?.hasChanges,\n              networkStatus.streaming?.hasChanges\n            ].some(Boolean)\n            \n            if (hasUpdates) {\n              updateCount++\n            }\n            \n            if (elapsed >= maxWait || updateCount >= 2) {\n              clearInterval(interval)\n              resolve({\n                success: updateCount >= 1, // At least 1 update in 12 seconds\n                data: {\n                  duration: elapsed,\n                  updates: updateCount,\n                  expectedInterval: 5000,\n                  streamsActive: [\n                    opportunities.streaming?.isConnected,\n                    dashboardSummary.streaming?.isConnected,\n                    networkStatus.streaming?.isConnected\n                  ].filter(Boolean).length\n                }\n              })\n            }\n          }, 1000)\n        })\n      }\n    }\n  ]\n\n  const runTest = async (testDef: any): Promise<TestResult> => {\n    const startTime = Date.now()\n    \n    try {\n      const result = await testDef.test()\n      const duration = Date.now() - startTime\n      \n      return {\n        id: testDef.id,\n        name: testDef.name,\n        description: testDef.description,\n        status: result.success ? 'success' : 'error',\n        duration,\n        data: result.data,\n        error: result.success ? undefined : 'Test failed'\n      }\n    } catch (error) {\n      const duration = Date.now() - startTime\n      \n      return {\n        id: testDef.id,\n        name: testDef.name,\n        description: testDef.description,\n        status: 'error',\n        duration,\n        error: error instanceof Error ? error.message : 'Unknown error'\n      }\n    }\n  }\n\n  const runAllTests = async () => {\n    setIsRunning(true)\n    setOverallStatus('running')\n    \n    const initialTests = testDefinitions.map(testDef => ({\n      id: testDef.id,\n      name: testDef.name,\n      description: testDef.description,\n      status: 'pending' as const\n    }))\n    \n    setTests(initialTests)\n    \n    const results: TestResult[] = []\n    \n    for (const testDef of testDefinitions) {\n      // Update status to running\n      setTests(prev => prev.map(test => \n        test.id === testDef.id ? { ...test, status: 'running' } : test\n      ))\n      \n      const result = await runTest(testDef)\n      results.push(result)\n      \n      // Update with result\n      setTests(prev => prev.map(test => \n        test.id === testDef.id ? result : test\n      ))\n    }\n    \n    const failedTests = results.filter(test => test.status === 'error')\n    setOverallStatus(failedTests.length === 0 ? 'completed' : 'failed')\n    setIsRunning(false)\n  }\n\n  const getStatusIcon = (status: TestResult['status']) => {\n    switch (status) {\n      case 'pending': return <Clock className=\"w-4 h-4 text-gray-400\" />\n      case 'running': return <RefreshCw className=\"w-4 h-4 text-blue-500 animate-spin\" />\n      case 'success': return <CheckCircle2 className=\"w-4 h-4 text-green-500\" />\n      case 'error': return <XCircle className=\"w-4 h-4 text-red-500\" />\n    }\n  }\n\n  const getStatusColor = (status: TestResult['status']) => {\n    switch (status) {\n      case 'pending': return 'border-gray-200 bg-gray-50'\n      case 'running': return 'border-blue-200 bg-blue-50'\n      case 'success': return 'border-green-200 bg-green-50'\n      case 'error': return 'border-red-200 bg-red-50'\n    }\n  }\n\n  const successCount = tests.filter(test => test.status === 'success').length\n  const errorCount = tests.filter(test => test.status === 'error').length\n  const runningCount = tests.filter(test => test.status === 'running').length\n\n  return (\n    <div className={cn(\"space-y-6\", className)}>\n      {/* Header de Testing */}\n      <Card className=\"bg-gradient-to-r from-blue-50 to-indigo-50 border-blue-200\">\n        <CardHeader>\n          <div className=\"flex items-center justify-between\">\n            <div>\n              <CardTitle className=\"flex items-center space-x-3\">\n                <Zap className=\"w-6 h-6 text-blue-600\" />\n                <span className=\"text-xl font-bold text-blue-900\">\n                  ArbitrageX Supreme - Test Suite Integral\n                </span>\n              </CardTitle>\n              <p className=\"text-blue-700 mt-2\">\n                Testing completo: 20 blockchains, 450+ protocolos, streaming anti-parpadeo cada 5s\n              </p>\n            </div>\n            <Button \n              onClick={runAllTests}\n              disabled={isRunning}\n              className=\"bg-blue-600 hover:bg-blue-700\"\n            >\n              {isRunning ? (\n                <>\n                  <RefreshCw className=\"w-4 h-4 mr-2 animate-spin\" />\n                  Ejecutando Tests...\n                </>\n              ) : (\n                <>\n                  <Activity className=\"w-4 h-4 mr-2\" />\n                  Ejecutar Tests\n                </>\n              )}\n            </Button>\n          </div>\n        </CardHeader>\n      </Card>\n\n      {/* Métricas del Test Suite */}\n      {tests.length > 0 && (\n        <div className=\"grid grid-cols-2 lg:grid-cols-4 gap-4\">\n          <AntiFlickerMetricCard\n            title=\"Tests Ejecutados\"\n            value={tests.length}\n            subtitle=\"Total de pruebas\"\n            icon={<Database className=\"w-5 h-5\" />}\n          />\n          \n          <AntiFlickerMetricCard\n            title=\"Tests Exitosos\"\n            value={successCount}\n            subtitle={`${tests.length > 0 ? Math.round((successCount / tests.length) * 100) : 0}% completado`}\n            icon={<CheckCircle2 className=\"w-5 h-5\" />}\n            trend={successCount > errorCount ? 'up' : 'down'}\n            trendValue={`${successCount}/${tests.length}`}\n          />\n          \n          <AntiFlickerMetricCard\n            title=\"Tests Fallidos\"\n            value={errorCount}\n            subtitle=\"Requieren atención\"\n            icon={<XCircle className=\"w-5 h-5\" />}\n            trend={errorCount === 0 ? 'up' : 'down'}\n            trendValue={errorCount === 0 ? 'Perfecto' : 'Revisar'}\n          />\n          \n          <AntiFlickerMetricCard\n            title=\"Tiempo Promedio\"\n            value={tests.length > 0 ? Math.round(tests.reduce((sum, test) => sum + (test.duration || 0), 0) / tests.length) : 0}\n            subtitle=\"ms por test\"\n            icon={<Clock className=\"w-5 h-5\" />}\n            valueFormatter={(val) => `${val}ms`}\n          />\n        </div>\n      )}\n\n      {/* Lista de Tests */}\n      {tests.length > 0 && (\n        <Card>\n          <CardHeader>\n            <CardTitle className=\"flex items-center space-x-2\">\n              <Activity className=\"w-5 h-5 text-green-600\" />\n              <span>Resultados de Tests</span>\n              <Badge \n                variant=\"outline\" \n                className={cn(\n                  \"ml-auto\",\n                  overallStatus === 'completed' && 'bg-green-50 text-green-700 border-green-200',\n                  overallStatus === 'failed' && 'bg-red-50 text-red-700 border-red-200',\n                  overallStatus === 'running' && 'bg-blue-50 text-blue-700 border-blue-200'\n                )}\n              >\n                {overallStatus === 'completed' && 'Tests Completados'}\n                {overallStatus === 'failed' && 'Tests con Errores'}\n                {overallStatus === 'running' && 'Ejecutando...'}\n                {overallStatus === 'idle' && 'Listo para ejecutar'}\n              </Badge>\n            </CardTitle>\n          </CardHeader>\n          <CardContent>\n            <div className=\"space-y-4\">\n              {tests.map((test) => (\n                <div \n                  key={test.id}\n                  className={cn(\n                    \"flex items-center justify-between p-4 rounded-lg border transition-all duration-300\",\n                    getStatusColor(test.status)\n                  )}\n                >\n                  <div className=\"flex items-center space-x-4\">\n                    {getStatusIcon(test.status)}\n                    <div>\n                      <h4 className=\"font-medium text-gray-900\">{test.name}</h4>\n                      <p className=\"text-sm text-gray-600\">{test.description}</p>\n                      {test.error && (\n                        <p className=\"text-sm text-red-600 mt-1\">Error: {test.error}</p>\n                      )}\n                    </div>\n                  </div>\n                  \n                  <div className=\"text-right\">\n                    {test.duration && (\n                      <p className=\"text-sm font-medium text-gray-700\">\n                        {test.duration}ms\n                      </p>\n                    )}\n                    {test.data && test.status === 'success' && (\n                      <p className=\"text-xs text-gray-500\">\n                        {JSON.stringify(test.data).length > 50 \n                          ? 'Datos disponibles' \n                          : JSON.stringify(test.data)\n                        }\n                      </p>\n                    )}\n                  </div>\n                </div>\n              ))}\n            </div>\n          </CardContent>\n        </Card>\n      )}\n\n      {/* Status de Streams en Tiempo Real */}\n      <Card>\n        <CardHeader>\n          <CardTitle className=\"flex items-center space-x-2\">\n            <TrendingUp className=\"w-5 h-5 text-blue-600\" />\n            <span>Status de Streaming en Tiempo Real</span>\n          </CardTitle>\n        </CardHeader>\n        <CardContent>\n          <div className=\"grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4\">\n            {[\n              { name: 'Oportunidades', hook: opportunities, path: '/api/v2/arbitrage/opportunities' },\n              { name: 'Dashboard', hook: dashboardSummary, path: '/api/v2/dashboard/summary' },\n              { name: 'Redes', hook: networkStatus, path: '/api/v2/blockchain/network-status' },\n              { name: 'Métricas', hook: performanceMetrics, path: '/api/v2/dashboard/metrics' },\n              { name: 'Protocolos', hook: protocolsData, path: '/api/v2/dashboard/protocols' },\n              { name: 'Blockchains', hook: supportedBlockchains, path: '/api/v2/blockchain/supported' }\n            ].map((stream) => (\n              <div key={stream.name} className=\"p-4 border rounded-lg\">\n                <div className=\"flex items-center justify-between mb-2\">\n                  <h4 className=\"font-medium\">{stream.name}</h4>\n                  <div className={cn(\n                    \"w-3 h-3 rounded-full\",\n                    stream.hook.streaming?.isConnected ? 'bg-green-400' : 'bg-red-400'\n                  )} />\n                </div>\n                <div className=\"space-y-1 text-sm text-gray-600\">\n                  <p>Conectado: {stream.hook.streaming?.isConnected ? 'Sí' : 'No'}</p>\n                  <p>Actualizando: {stream.hook.streaming?.isUpdating ? 'Sí' : 'No'}</p>\n                  <p>Datos: {stream.hook.streaming?.hasData ? 'Disponibles' : 'Sin datos'}</p>\n                  <p className=\"text-xs text-gray-500\">{stream.path}</p>\n                </div>\n              </div>\n            ))}\n          </div>\n        </CardContent>\n      </Card>\n    </div>\n  )\n}\n"