/**
 * ArbitrageX Supreme - Script de Prueba del Sistema de Alertas
 * Ingenio Pichichi S.A. - Actividad 7.8
 * 
 * Script completo de verificaci√≥n y pruebas del sistema de alertas:
 * - Pruebas de API REST
 * - Pruebas de detecci√≥n de anomal√≠as
 * - Pruebas de notificaciones
 * - Pruebas de dashboard
 * 
 * TODO FUNCIONAL Y SIN UN SOLO MOCK
 */

const axios = require('axios');

// Configuraci√≥n del servidor
const BASE_URL = process.env.TEST_SERVER_URL || 'http://localhost:3001';
const API_BASE = `${BASE_URL}/api/v2/alerts`;

/**
 * Colores para output en consola
 */
const colors = {
  reset: '\x1b[0m',
  green: '\x1b[32m',
  red: '\x1b[31m',
  yellow: '\x1b[33m',
  blue: '\x1b[34m',
  magenta: '\x1b[35m',
  cyan: '\x1b[36m'
};

function log(message, color = 'reset') {
  console.log(`${colors[color]}${message}${colors.reset}`);
}

/**
 * Funci√≥n auxiliar para realizar peticiones HTTP
 */
async function request(method, url, data = null) {
  try {
    const config = {
      method,
      url: `${API_BASE}${url}`,
      timeout: 10000
    };

    if (data) {
      config.data = data;
      config.headers = { 'Content-Type': 'application/json' };
    }

    const response = await axios(config);
    return {
      success: true,
      status: response.status,
      data: response.data
    };
  } catch (error) {
    return {
      success: false,
      status: error.response?.status || 0,
      error: error.message,
      data: error.response?.data
    };
  }
}

/**
 * Prueba 1: Verificar estado de salud del sistema
 */
async function testHealthCheck() {
  log('\n=== PRUEBA 1: Estado de Salud del Sistema ===', 'cyan');
  
  const result = await request('GET', '/health');
  
  if (result.success) {
    log('‚úÖ Estado de salud OK', 'green');
    log(`Datos: ${JSON.stringify(result.data, null, 2)}`, 'blue');
    return true;
  } else {
    log(`‚ùå Error verificando salud: ${result.error}`, 'red');
    return false;
  }
}

/**
 * Prueba 2: Crear alertas de prueba
 */
async function testCreateAlerts() {
  log('\n=== PRUEBA 2: Creaci√≥n de Alertas ===', 'cyan');
  
  const testAlerts = [
    {
      type: 'CRITICAL',
      category: 'trading',
      title: 'Prueba - Latencia Cr√≠tica',
      description: 'Latencia de trading excede umbral cr√≠tico en pruebas automatizadas',
      source: 'test-script',
      context: { test: true, timestamp: Date.now() }
    },
    {
      type: 'HIGH',
      category: 'security',
      title: 'Prueba - Intento de Acceso No Autorizado',
      description: 'M√∫ltiples intentos fallidos detectados durante pruebas de seguridad',
      source: 'test-script',
      context: { test: true, timestamp: Date.now() }
    },
    {
      type: 'MEDIUM',
      category: 'system',
      title: 'Prueba - Uso Elevado de Recursos',
      description: 'Uso de CPU/memoria superior al normal durante pruebas de carga',
      source: 'test-script',
      context: { test: true, timestamp: Date.now() }
    }
  ];

  const createdAlerts = [];
  
  for (const [index, alertData] of testAlerts.entries()) {
    log(`\nCreando alerta ${index + 1}/3: ${alertData.title}`, 'yellow');
    
    const result = await request('POST', '', alertData);
    
    if (result.success) {
      log(`‚úÖ Alerta creada: ID ${result.data.data.id}`, 'green');
      createdAlerts.push(result.data.data);
    } else {
      log(`‚ùå Error creando alerta: ${result.error}`, 'red');
      log(`Detalles: ${JSON.stringify(result.data, null, 2)}`, 'red');
    }
  }
  
  return createdAlerts;
}

/**
 * Prueba 3: Obtener lista de alertas
 */
async function testGetAlerts() {
  log('\n=== PRUEBA 3: Obtener Lista de Alertas ===', 'cyan');
  
  const result = await request('GET', '');
  
  if (result.success) {
    log('‚úÖ Lista de alertas obtenida', 'green');
    log(`Total de alertas: ${result.data.data.total}`, 'blue');
    log(`Alertas activas: ${result.data.data.active}`, 'blue');
    return result.data.data.alerts;
  } else {
    log(`‚ùå Error obteniendo alertas: ${result.error}`, 'red');
    return [];
  }
}

/**
 * Prueba 4: Reconocer una alerta
 */
async function testAcknowledgeAlert(alertId) {
  log('\n=== PRUEBA 4: Reconocimiento de Alerta ===', 'cyan');
  
  if (!alertId) {
    log('‚ö†Ô∏è  No hay alertas disponibles para reconocer', 'yellow');
    return false;
  }

  const result = await request('POST', `/${alertId}/acknowledge`, {
    acknowledgedBy: 'test-script-user'
  });
  
  if (result.success) {
    log(`‚úÖ Alerta ${alertId} reconocida exitosamente`, 'green');
    return true;
  } else {
    log(`‚ùå Error reconociendo alerta: ${result.error}`, 'red');
    return false;
  }
}

/**
 * Prueba 5: Resolver una alerta
 */
async function testResolveAlert(alertId) {
  log('\n=== PRUEBA 5: Resoluci√≥n de Alerta ===', 'cyan');
  
  if (!alertId) {
    log('‚ö†Ô∏è  No hay alertas disponibles para resolver', 'yellow');
    return false;
  }

  const result = await request('POST', `/${alertId}/resolve`, {
    resolvedBy: 'test-script-user',
    resolution: 'Problema resuelto durante pruebas automatizadas'
  });
  
  if (result.success) {
    log(`‚úÖ Alerta ${alertId} resuelta exitosamente`, 'green');
    return true;
  } else {
    log(`‚ùå Error resolviendo alerta: ${result.error}`, 'red');
    return false;
  }
}

/**
 * Prueba 6: Obtener estad√≠sticas
 */
async function testGetStatistics() {
  log('\n=== PRUEBA 6: Estad√≠sticas del Sistema ===', 'cyan');
  
  const result = await request('GET', '/statistics');
  
  if (result.success) {
    log('‚úÖ Estad√≠sticas obtenidas', 'green');
    log(`Datos: ${JSON.stringify(result.data.data, null, 2)}`, 'blue');
    return true;
  } else {
    log(`‚ùå Error obteniendo estad√≠sticas: ${result.error}`, 'red');
    return false;
  }
}

/**
 * Prueba 7: Registrar m√©tricas para detecci√≥n de anomal√≠as
 */
async function testRecordMetrics() {
  log('\n=== PRUEBA 7: Registro de M√©tricas ===', 'cyan');
  
  const testMetrics = [
    { metricName: 'cpu_usage', value: 85.5, metadata: { source: 'test', unit: 'percentage' } },
    { metricName: 'memory_usage', value: 78.2, metadata: { source: 'test', unit: 'percentage' } },
    { metricName: 'trading_latency', value: 450, metadata: { source: 'test', unit: 'milliseconds' } },
    { metricName: 'api_requests_per_second', value: 125, metadata: { source: 'test', unit: 'count' } }
  ];
  
  let successCount = 0;
  
  for (const metric of testMetrics) {
    const result = await request('POST', '/metrics', metric);
    
    if (result.success) {
      log(`‚úÖ M√©trica registrada: ${metric.metricName} = ${metric.value}`, 'green');
      successCount++;
    } else {
      log(`‚ùå Error registrando m√©trica ${metric.metricName}: ${result.error}`, 'red');
    }
  }
  
  return successCount === testMetrics.length;
}

/**
 * Prueba 8: Generar alertas de demostraci√≥n
 */
async function testDemoAlerts() {
  log('\n=== PRUEBA 8: Generaci√≥n de Alertas Demo ===', 'cyan');
  
  const result = await request('GET', '/demo');
  
  if (result.success) {
    log('‚úÖ Alertas de demostraci√≥n generadas', 'green');
    log(`Alertas creadas: ${result.data.data.alertsCreated}`, 'blue');
    return result.data.data.alerts;
  } else {
    log(`‚ùå Error generando alertas demo: ${result.error}`, 'red');
    return [];
  }
}

/**
 * Prueba 9: Verificar dashboard HTML
 */
async function testDashboard() {
  log('\n=== PRUEBA 9: Dashboard HTML ===', 'cyan');
  
  try {
    const response = await axios.get(`${API_BASE}/dashboard`, {
      timeout: 10000,
      headers: { 'Accept': 'text/html' }
    });
    
    if (response.status === 200 && response.data.includes('html')) {
      log('‚úÖ Dashboard HTML generado correctamente', 'green');
      log(`Tama√±o del HTML: ${response.data.length} caracteres`, 'blue');
      return true;
    } else {
      log('‚ùå Dashboard no retorn√≥ HTML v√°lido', 'red');
      return false;
    }
  } catch (error) {
    log(`‚ùå Error accediendo al dashboard: ${error.message}`, 'red');
    return false;
  }
}

/**
 * Prueba 10: Verificar servidor principal
 */
async function testServerHealth() {
  log('\n=== PRUEBA 10: Estado del Servidor Principal ===', 'cyan');
  
  try {
    const response = await axios.get(`${BASE_URL}/health`, { timeout: 5000 });
    
    if (response.status === 200) {
      log('‚úÖ Servidor principal funcionando correctamente', 'green');
      log(`Estado: ${response.data.status}`, 'blue');
      log(`Database: ${response.data.database}`, 'blue');
      log(`Redis: ${response.data.redis}`, 'blue');
      return true;
    } else {
      log(`‚ùå Servidor principal en estado no saludable: ${response.status}`, 'red');
      return false;
    }
  } catch (error) {
    log(`‚ùå Error verificando servidor principal: ${error.message}`, 'red');
    log('‚ö†Ô∏è  Aseg√∫rese de que el servidor est√© ejecut√°ndose en el puerto correcto', 'yellow');
    return false;
  }
}

/**
 * Funci√≥n principal de ejecuci√≥n de pruebas
 */
async function runAllTests() {
  log('üöÄ INICIANDO PRUEBAS DEL SISTEMA DE ALERTAS - ARBITRAGEX SUPREME', 'magenta');
  log('Ingenio Pichichi S.A. - Actividad 7.8 - TODO FUNCIONAL Y SIN UN SOLO MOCK', 'magenta');
  log(`Servidor objetivo: ${BASE_URL}`, 'cyan');
  
  const results = {
    total: 0,
    passed: 0,
    failed: 0,
    details: []
  };

  // Lista de pruebas a ejecutar
  const tests = [
    { name: 'Estado del Servidor Principal', func: testServerHealth },
    { name: 'Estado de Salud del Sistema de Alertas', func: testHealthCheck },
    { name: 'Creaci√≥n de Alertas', func: testCreateAlerts },
    { name: 'Obtener Lista de Alertas', func: testGetAlerts },
    { name: 'Registro de M√©tricas', func: testRecordMetrics },
    { name: 'Generaci√≥n de Alertas Demo', func: testDemoAlerts },
    { name: 'Dashboard HTML', func: testDashboard },
    { name: 'Estad√≠sticas del Sistema', func: testGetStatistics }
  ];

  let createdAlerts = [];
  
  // Ejecutar pruebas secuencialmente
  for (const test of tests) {
    results.total++;
    
    try {
      log(`\n‚è≥ Ejecutando: ${test.name}...`, 'yellow');
      const result = await test.func();
      
      if (Array.isArray(result)) {
        // Si la funci√≥n retorna un array (como createdAlerts)
        createdAlerts = result;
        results.passed++;
        results.details.push({ name: test.name, status: 'PASSED', data: result });
      } else if (result === true) {
        results.passed++;
        results.details.push({ name: test.name, status: 'PASSED' });
      } else {
        results.failed++;
        results.details.push({ name: test.name, status: 'FAILED' });
      }
    } catch (error) {
      results.failed++;
      results.details.push({ name: test.name, status: 'ERROR', error: error.message });
      log(`üí• Error ejecutando ${test.name}: ${error.message}`, 'red');
    }
  }

  // Pruebas adicionales con alertas creadas
  if (createdAlerts.length > 0) {
    // Test reconocimiento de alerta
    results.total++;
    try {
      const ackResult = await testAcknowledgeAlert(createdAlerts[0].id);
      if (ackResult) {
        results.passed++;
        results.details.push({ name: 'Reconocimiento de Alerta', status: 'PASSED' });
      } else {
        results.failed++;
        results.details.push({ name: 'Reconocimiento de Alerta', status: 'FAILED' });
      }
    } catch (error) {
      results.failed++;
      results.details.push({ name: 'Reconocimiento de Alerta', status: 'ERROR', error: error.message });
    }

    // Test resoluci√≥n de alerta
    if (createdAlerts.length > 1) {
      results.total++;
      try {
        const resolveResult = await testResolveAlert(createdAlerts[1].id);
        if (resolveResult) {
          results.passed++;
          results.details.push({ name: 'Resoluci√≥n de Alerta', status: 'PASSED' });
        } else {
          results.failed++;
          results.details.push({ name: 'Resoluci√≥n de Alerta', status: 'FAILED' });
        }
      } catch (error) {
        results.failed++;
        results.details.push({ name: 'Resoluci√≥n de Alerta', status: 'ERROR', error: error.message });
      }
    }
  }

  // Reporte final
  log('\n' + '='.repeat(80), 'magenta');
  log('üìä REPORTE FINAL DE PRUEBAS', 'magenta');
  log('='.repeat(80), 'magenta');
  
  log(`\nüî¢ Resumen:`, 'cyan');
  log(`   Total de pruebas: ${results.total}`, 'blue');
  log(`   Exitosas: ${results.passed}`, 'green');
  log(`   Fallidas: ${results.failed}`, 'red');
  log(`   Porcentaje de √©xito: ${((results.passed / results.total) * 100).toFixed(1)}%`, 
      results.passed === results.total ? 'green' : 'yellow');

  log(`\nüìã Detalle de resultados:`, 'cyan');
  results.details.forEach((detail, index) => {
    const status = detail.status === 'PASSED' ? '‚úÖ' : 
                   detail.status === 'FAILED' ? '‚ùå' : 'üí•';
    const color = detail.status === 'PASSED' ? 'green' : 'red';
    log(`   ${index + 1}. ${status} ${detail.name}`, color);
    
    if (detail.error) {
      log(`      Error: ${detail.error}`, 'red');
    }
  });

  // Conclusiones y recomendaciones
  log(`\nüéØ Conclusiones:`, 'cyan');
  
  if (results.passed === results.total) {
    log('   ‚úÖ TODAS LAS PRUEBAS PASARON EXITOSAMENTE', 'green');
    log('   üöÄ El sistema de alertas est√° completamente funcional', 'green');
    log('   üì± Dashboard y APIs est√°n operativos', 'green');
    log('   üîî Detecci√≥n de anomal√≠as y notificaciones funcionando', 'green');
  } else if (results.passed > results.failed) {
    log('   ‚ö†Ô∏è  MAYOR√çA DE PRUEBAS EXITOSAS', 'yellow');
    log('   üîß Revisar pruebas fallidas para optimizaci√≥n', 'yellow');
  } else {
    log('   ‚ùå M√öLTIPLES FALLAS DETECTADAS', 'red');
    log('   üõ†Ô∏è  Se requiere revisi√≥n del sistema', 'red');
  }

  log('\nüìñ URLs importantes:', 'cyan');
  log(`   üè• Health Check: ${BASE_URL}/health`, 'blue');
  log(`   üö® Alertas API: ${API_BASE}`, 'blue');
  log(`   üì± Dashboard: ${API_BASE}/dashboard`, 'blue');
  log(`   üìä Estad√≠sticas: ${API_BASE}/statistics`, 'blue');
  log(`   üîç Demo Alertas: ${API_BASE}/demo`, 'blue');

  log('\nüèÅ PRUEBAS COMPLETADAS - ArbitrageX Supreme', 'magenta');
  log('TODO FUNCIONAL Y SIN UN SOLO MOCK ‚úÖ', 'green');
  
  return results;
}

// Ejecutar pruebas si el script se ejecuta directamente
if (require.main === module) {
  runAllTests()
    .then((results) => {
      process.exit(results.failed === 0 ? 0 : 1);
    })
    .catch((error) => {
      log(`üí• Error ejecutando pruebas: ${error.message}`, 'red');
      process.exit(1);
    });
}

module.exports = {
  runAllTests,
  testHealthCheck,
  testCreateAlerts,
  testGetAlerts,
  testAcknowledgeAlert,
  testResolveAlert,
  testGetStatistics,
  testRecordMetrics,
  testDemoAlerts,
  testDashboard,
  testServerHealth
};